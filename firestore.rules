/**
 * @file Firebase Security Rules for Nexus Teams Application
 *
 * @core_philosophy This ruleset enforces a strict user-ownership model for user profiles,
 *                  shared access for team profiles and chat messages, and public read access
 *                  for hackathon listings. It prioritizes security by validating ownership
 *                  and using denormalized data for efficient authorization checks.
 *
 * @data_structure
 * - /users/{userId}: User profile data, accessible only by the user.
 * - /teams/{teamId}: Team profile data, accessible by team members.
 * - /hackathons/{hackathonId}: Hackathon listings, publicly readable.
 * - /teams/{teamId}/messages/{messageId}: Chat messages within a team,
 *   accessible by team members.
 *
 * @key_security_decisions
 * - User profiles are strictly private; only the authenticated user can access their own profile.
 * - Team profiles and chat messages use a shared access model based on team membership (memberIds).
 * - Hackathon listings are publicly readable to facilitate discovery.
 * - Listing user profiles is explicitly disallowed to protect user privacy.
 * - Data consistency is enforced by validating the 'id' field on create and update operations
 *   to match the document ID, ensuring ownership is maintained.
 *
 * @denormalization_for_authorization
 * - TeamProfile.memberIds: The list of member IDs is denormalized into the TeamProfile document
 *   to avoid requiring a `get()` operation to the `/users/{userId}` document for authorization.
 *   This allows checking team membership directly within the TeamProfile rules.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secures user profile data, ensuring only the authenticated user can
     *              access their own profile.
     * @path /users/{userId}
     * @allow (create) User A creates their own profile with matching userId.
     *        (auth.uid == 'userA', request.resource.data.id == 'userA')
     * @allow (get, update, delete) User A reads/updates/deletes their own profile.
     *        (auth.uid == 'userA', resource.data.id == 'userA')
     * @deny  (create, get, update, delete) User A tries to access User B's profile.
     *        (auth.uid == 'userA', userId == 'userB')
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isOwner() {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner() {
        return isOwner() && resource != null;
      }

      allow get: if isOwner();
      allow list: if false; // Prevent listing of user profiles.
      allow create: if isOwner() && request.resource.data.id == userId;
      allow update: if isExistingOwner() && request.resource.data.id == resource.data.id; // Enforce immutability of userId.
      allow delete: if isExistingOwner();
    }

    /**
     * @description Secures team profile data, allowing access only to team members.
     * @path /teams/{teamId}
     * @allow (get, list) Any team member can read the team profile.
     *        (auth.uid is in resource.data.teamMemberIds)
     * @allow (create) Any authenticated user can create a team profile (but they should be added as a member).
     *        (request.auth != null)
     * @allow (update, delete) Only team members can update/delete the team profile.
     *        (auth.uid is in resource.data.teamMemberIds)
     * @deny  (get, update, delete) Non-team members cannot access the team profile.
     *        (auth.uid is not in resource.data.teamMemberIds)
     * @principle Enforces shared access based on team membership (teamMemberIds).
     */
    match /teams/{teamId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isTeamMember() {
        return isSignedIn() && resource.data.teamMemberIds.hasAny([request.auth.uid]);
      }

      allow get, list: if true; // TODO: Secure list with a query that ensures team membership.
      allow create: if isSignedIn();
      allow update, delete: if isTeamMember();
    }

    /**
     * @description Allows public read access to hackathon listings.
     * @path /hackathons/{hackathonId}
     * @allow (get, list) Any user can read hackathon listings.
     *        (true)
     * @deny  (create, update, delete) No user can create, update, or delete hackathon listings.
     *        (false)
     * @principle Provides public read access while restricting write access.
     */
    match /hackathons/{hackathonId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Secures chat messages within a team, allowing access only to team members.
     * @path /teams/{teamId}/messages/{messageId}
     * @allow (get, list, create) Only team members can read/create chat messages.
     *        (auth.uid is in get(/databases/$(database)/documents/teams/$(teamId)).data.teamMemberIds)
     * @allow (update, delete) No user can update or delete chat messages.
     *        (false)
     * @deny  (get, list, create) Non-team members cannot access chat messages.
     *        (auth.uid is not in get(/databases/$(database)/documents/teams/$(teamId)).data.teamMemberIds)
     * @principle Enforces shared access based on team membership (lookups the parent document).
     */
    match /teams/{teamId}/messages/{messageId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isTeamMember() {
        let teamDoc = get(/databases/$(database)/documents/teams/$(teamId));
        return isSignedIn() && teamDoc.data.teamMemberIds.hasAny([request.auth.uid]);
      }

      allow get, list, create: if isTeamMember();
      allow update, delete: if false;
    }
  }
}